% This document is designed to produce a french speaking report.

\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[main=english]{babel}
\usepackage{url}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[a4paper, margin=2cm, footskip=18.3pt]{geometry}
\usepackage{listings}
\usepackage{pdflscape}
\usepackage{color}

\newcommand{\header} {
    \setlength{\headheight}{30pt}\pagestyle{fancy}
    \fancyhead[L]{\includegraphics[height=20pt]{~/Templates/heig-logo}}\fancyhead[C]{PCO 2023\\ Lab 4}
    \fancyhead[R]{Aubry Mangold, Timothée Van Hove\\\today}\fancyfoot[C]{}
    \fancyfoot[R]{Page \thepage~sur \pageref{LastPage}}\renewcommand{\footrulewidth}{0.3pt}
}

\lstset{frame=tb,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}

\begin{document}
    \header

    \section{Introduction}

    The goal of this lab is to implement the management of a shared rail section in a train simulation.
    The source code of the simulator and a program boilerplate for the student program are provided.
    The simulator is a multi threaded program that simulates the behavior of a train on a rail network, leading to
    synchronization problems.
    The student program must implement the management of the shared rail section, the synchronization between the trains
    at the station and an emergency stop system.

    \section{Analysis}

    Our analysis began with identifying the complexities in a multi-threaded train simulation. The primary challenge lies in the synchronization of two trains running on separate threads, especially in shared track sections and stations – the critical sections. These areas are akin to shared resources, where improper management can lead to collisions or deadlocks

    We identified the risk of deadlocks as particularly pertinent, where two trains might attempt to enter the same section, leading to an indefinite waiting scenario. To address this, we focused on the principles of active waiting and mutual exclusion. Active waiting, ensures that a train remains responsive while waiting for a shared section to become available. Mutual exclusion, achieved with a semaphore, guarantees that shared resources are accessed in an exclusive, manner.

    To solve the critical sections challenges we are going to use both active waiting to ensure the access to only 1 train and mutual exclusion to ensure that the shared resources are accessed correctly. Stations are critical points where and coordination are essential. Therefore, we devised a system not just to manage station occupancy but also to synchronize the order of train departure.

    \section{Conception}

    To address station synchronization, our solution incorporates a barrier mechanism for station synchronization. This barrier not only ensures orderly train departures but also integrates a priority system, giving precedence to the last arriving train to enhance operational efficiency.

    For managing the shared section, we established a synchronization logic. This system ensures that while one train occupies this critical section, the other train waits. As soon as the first train exits the section, the waiting train receives clearance to enter. This approach effectively prevents conflicts and ensures safe passage through the shared track section.

    \pagebreak

    \section{Implementation}

    In the implementation of our train simulation system, we began by selecting the route for each locomotive. These routes are dynamically generated using the routeFactory function, which not only sets up specific track junction configurations but also establishes parameters for each train's journey, including how they navigate shared track sections.

    In the main function, we initialize the model railway system. Locomotives A and B are initialized with unique identifiers and predetermined speeds, and their starting positions are determined by the route configuration. The simulation is initiated with the launching of the locomotive threads. It runs continuously, monitoring for any external conditions or the activation of the emergency stop, which would bring the operation to a halt. The two threads launch an instance of the runnable locomotivebehavior class. In this class, the run() method is responsible for dictating the locomotive's actions, encompassing station stops, navigation through shared sections, and responses to track junctions.

    \begin{lstlisting}
        void LocomotiveBehavior::run(){
            // Initial entry into the station.
            attendre_contact(station);

            while (true) {
                sections.front().synchro->stopAtStation(loco);

                // Go through each section
                for (const auto& section : sections) {
                    // Wait for the warning contact to be triggered, if any.
                    if (section.contactWarn != station) {
                        attendre_contact(section.contactWarn);
                    }

                    // The first departed locomotive gets priority in the first shared section.
                    if (loco.priority == 0) {
                        loco.priority++;
                    } else {
                        section.synchro->access(loco);
                    }

                    // Toggle the junctions once the section entry contact is hit.
                    attendre_contact(section.contactEnter);
                    diriger_aiguillage(section.junctionEntry.junctionId,
                                    section.junctionEntry.direction, 0);
                    diriger_aiguillage(section.junctionExit.junctionId,
                                    section.junctionExit.direction, 0);

                    // Release the shared section after passing the exit contact.
                    attendre_contact(section.contactExit);
                    section.synchro->leave(loco);
                }

                // Wait for the station contact if it is different from the section exit contact.
                if (station != sections.back().contactExit) {
                    attendre_contact(station);
                }
            }
        }
    \end{lstlisting}

    \pagebreak

    Synchronization of shared track sections is a critical aspect of our implementation. We employed the Synchro class to manage access to these sections. The methods access(), leave(), and stopAtStation() ensure that only one train occupies a shared section at any given time, effectively preventing the risk of collisions.

    \begin{lstlisting}
    void access(Locomotive& loco) override {
        mutexSection.acquire();

        // If the section isn't free, stop the loco and wait to acquire it.
        if (!isSectionFree) {
            loco.arreter();

            // Set the other loco to wait.
            otherIsWaiting = true;
            mutexSection.release();

            // Blockingly wait for the section to be free.
            sectionSemaphore.acquire();
            mutexSection.acquire();
            otherIsWaiting = false;
            loco.demarrer();
        }

        // Set the section to occupied now that a loco has acquired it.
        isSectionFree = false;
        mutexSection.release();
    }
    \end{lstlisting}

    \begin{lstlisting}
    void leave(Locomotive& loco) override {
        mutexSection.acquire();
        isSectionFree = true;

        // Give access to the other loco if it is waiting.
        if (otherIsWaiting) {
            sectionSemaphore.release();
        }
        mutexSection.release();
    }
    \end{lstlisting}

    \pagebreak

    Station management is another key feature to control access to the station and ensure orderly operation. We implemented a barrier-like mechanism because this approach not only manages station occupancy but also assigns departure priority to the last train that arrives at the station.

    \begin{lstlisting}
        void stopAtStation(Locomotive& loco) override {

            // If the station is empty, stop the loco and set the station to occupied.
            mutexStation.acquire();
            if (!isStationOccupied) {
                isStationOccupied = true;
                mutexStation.release();
                loco.arreter();

                // Wait to be released by the last arrived loco.
                stationSemaphore.acquire();

                // Set the priority
                loco.priority = 1;
                loco.demarrer();
            } else {
                // If the station is occupied, wait for 5 seconds and have the last
                // arrived loco start first by already giving it access to the shared section.
                isStationOccupied = false;
                loco.arreter();
                PcoThread::usleep(5e6);

                // Give access to the shared section before releasing other locos so
                // that we're sure it can't be acquired by another loco.
                access(loco);

                // Release the semaphore to signal the first loco that it may continue.
                stationSemaphore.release();

                // Set the loco to the highest priority and restart it.
                // Note: this is useful in the LocoBehavior::run() while loop in order to avoid the
                // prioritized loco trying to acquire the shared section again.
                loco.priority = 0;
                loco.demarrer();
                mutexStation.release();
            }
        }
    \end{lstlisting}

    Finally, an emergency stop function was integrated. This function can be invoked to immediately halt both locomotives, setting their speeds to zero and ensuring an instantaneous stop. Upon conclusion, the simulation is gracefully terminated, ensuring the proper shutdown of all threads and the safe state of the train model system.



    \pagebreak

    \section{Tests}
    \subsection*{Shared section}
    % Describe the tests we've done to ensure the correctness of our implementation. This section is worth some points.
    In the testing phase of our train simulation system, we conducted a series of tests to ensure the robustness and reliability of our implementation. These tests were designed to cover a variety of scenarios, each introducing different complexities and challenges.

    \textbf{Testing with the Provided Train Route:} Initially, we tested the system using the provided default train route. This served as a baseline to verify the fundamental functionality of our implementation, including basic movement of the trains and basic synchronization in shared sections and at stations.

    \textbf{Shared Section Adjacent to the Station:} In this test, we evaluated the system's behavior when the shared section is located immediately next to the station. This scenario tested the synchronization logic's ability to handle rapid access to the shared section and the station.

    \textbf{Shared Section Just Before the Station:} Another scenario placed the shared section right before the station. This setup was aimed to tes the system's handling the efficiency of our synchronization mechanism, as trains transitioned quickly from a shared section to a station stop.

    \textbf{Shared Section Separated from the Station:} We also tested a route where the shared section was separated from the station by a few blocks. This scenario was aimed at evaluating the system under a more spread-out configuration, ensuring that our synchronization logic remained effective.

    \textbf{Route with Two Shared Sections:} Going further, we introduced a route featuring two shared sections. This more complex scenario tested the system's capability to manage multiple critical sections simultaneously, ensuring that each train could navigate through these sections without conflicts or deadlocks.

    \textbf{Route with Only a Station and a Shared Section:} Finally, we tested a minimalist route that included only a station and a shared section. This scenario allowed us to focus on the core functionality of our system, ensuring that even in a simplified setup, the trains could coordinate effectively, demonstrating the scalability and adaptability of our synchronization logic.


    \subsection*{Station synchronization}
        We validated that the last train to enter the station was the first one to leave the station. Furthermore, we've validated that there are no hiccups in the second locomotive that has to wait in the station.
    \subsection*{Emergency stop}

    We tested the emergency stop in different scenarios with the inertia taken into account:
    \begin{itemize}
        \item Just before the station. Inertia makes the train enter the station
        \item Just before the critical section. Inertia makes the train enter the section
        \item when only 1 train is the station
        \item when both trains are outside the station
        \item when both trains are outside the critical section
    \end{itemize}

    \section{Conclusion}

    In conclusion, our train simulation system successfully demonstrates the application of concurrent programming principles to a complex, real-world scenario. By employing semaphores and synchronization techniques, we effectively managed shared resources and ensured safe, conflict-free operation of two trains on a single track system. The diverse testing scenarios further validated the robustness of our implementation.

    \appendix

    \pagebreak

    \section{Train routes}
    % images of the train routes used in the tests

\end{document}
